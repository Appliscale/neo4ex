defmodule Neo4ex.PackStream.Decoder do
  @moduledoc """
  Decoding from Bolt Structures to Elixir types
  """

  import Neo4ex.PackStream.DecoderBuilder

  alias Neo4ex.Utils

  @spec decode(binary()) :: {term(), binary()}
  def decode(data), do: do_decode(data)

  # those are being generated by the macro
  register_decoder(nil, marker, data, do: {nil, data})
  register_decoder(false, marker, data, do: {false, data})
  register_decoder(true, marker, data, do: {true, data})

  register_decoder(Float, marker, data) do
    <<num::float, rest::binary>> = data
    {num, rest}
  end

  register_decoder(Integer, marker, data) do
    num_size = Utils.bit_size_for_term_size(marker, Integer)
    <<num::size(num_size), rest::binary>> = data
    {num, rest}
  end

  register_decoder(String, marker, data) do
    marker_size = Utils.bit_size_for_term_size(marker, String)
    <<str_length::size(marker_size), str::binary-size(str_length), rest::binary>> = data
    {str, rest}
  end

  register_decoder(BitString, marker, data) do
    marker_size = Utils.bit_size_for_term_size(marker, BitString)
    <<bytes_length::size(marker_size), bytes::binary-size(bytes_length), rest::binary>> = data
    {bytes, rest}
  end

  # PackStream only informs that the List/Map starts
  # it can't decode its items since those can be ANY type (some of them may need Bolt version information to be decoded)
  register_decoder(List, marker, data) do
    marker_size = Utils.bit_size_for_term_size(marker, List)
    <<list_length::size(marker_size), rest::binary>> = data
    {List.duplicate(nil, list_length), rest}
  end

  register_decoder(Map, marker, data) do
    marker_size = Utils.bit_size_for_term_size(marker, Map)
    <<map_size::size(marker_size), rest::binary>> = data
    # that's not pretty but compact
    {%{size: map_size}, rest}
  end

  # exception for small Integers without marker
  defp do_decode(<<int::signed-integer, rest::binary>>), do: {int, rest}
end
