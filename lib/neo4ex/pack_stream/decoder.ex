defmodule Neo4Ex.PackStream.Decoder do
  @moduledoc """
  Decoding from Bolt Structures to Elixir types
  """

  import Neo4Ex.PackStream.DecoderBuilder

  alias Neo4Ex.Utils
  alias Neo4Ex.PackStream.Markers

  @spec decode(binary()) :: {term(), binary()}
  def decode(data), do: do_decode(data)

  # those are being generated by the macro
  register_decoder(nil, marker, data, do: {nil, data})
  register_decoder(false, marker, data, do: {false, data})
  register_decoder(true, marker, data, do: {true, data})

  register_decoder(Float, marker, data) do
    <<num::float, rest::binary>> = data
    {num, rest}
  end

  register_decoder(Integer, marker, data) do
    marker_index = Integer |> Markers.get!() |> Enum.find_index(&(&1 == marker))
    num_size = Integer.pow(2, marker_index) * 8
    <<num::size(num_size), rest::binary>> = data
    {num, rest}
  end

  register_decoder(String, marker, data) do
    marker_size = Utils.bit_size_for_integer(marker)
    <<str_length::size(marker_size), str::binary-size(str_length), rest::binary>> = data
    {str, rest}
  end

  register_decoder(BitString, marker, data) do
    <<bytes_length, bytes::binary-size(bytes_length), rest::binary>> = data
    {bytes, rest}
  end

  # PackStream only informs that the List/Map starts
  # it can't decode its items since those can be ANY type (some of them may need Bolt version information to be decoded)
  register_decoder(List, marker, data) do
    marker_size = Utils.bit_size_for_integer(marker)
    <<list_length::size(marker_size), rest::binary>> = data
    {List.duplicate(nil, list_length), rest}
  end

  register_decoder(Map, marker, data) do
    marker_size = Utils.bit_size_for_integer(marker)
    <<map_size::size(marker_size), rest::binary>> = data
    # that's not pretty but compact
    {%{size: map_size}, rest}
  end

  # exception for small Integers without marker
  defp do_decode(<<int::signed-integer, rest::binary>>), do: {int, rest}
end
