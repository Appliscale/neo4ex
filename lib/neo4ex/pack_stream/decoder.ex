defmodule Neo4ex.PackStream.Decoder do
  @moduledoc """
  Decoding from Bolt Structures to Elixir types
  """

  import Neo4ex.PackStream.DecoderBuilder

  @spec decode(binary()) :: {term(), binary()}
  def decode(data), do: do_decode(data)

  # those are being generated by the macro
  register_decoder(nil, data, do: {nil, data})
  register_decoder(false, data, do: {false, data})
  register_decoder(true, data, do: {true, data})

  register_decoder(Float, <<num::float, rest::binary>>) do
    {num, rest}
  end

  register_decoder(Integer, <<num::signed-integer-size(_), rest::binary>>) do
    {num, rest}
  end

  register_decoder(String, <<str_length::size(_), str::binary-size(str_length), rest::binary>>) do
    {str, rest}
  end

  register_decoder(
    BitString,
    <<bytes_length::size(_), bytes::binary-size(bytes_length), rest::binary>>
  ) do
    {bytes, rest}
  end

  # PackStream only informs that the List/Map starts
  # it can't decode its items since those can be ANY type (some of them may need Bolt version information to be decoded)
  register_decoder(List, <<list_length::size(_), rest::binary>>) do
    {List.duplicate(nil, list_length), rest}
  end

  register_decoder(Map, <<map_size::size(_), rest::binary>>) do
    # that's not pretty but compact
    {%{size: map_size}, rest}
  end

  # exception for small Integers without marker
  defp do_decode(<<int::signed-integer, rest::binary>>), do: {int, rest}
end
