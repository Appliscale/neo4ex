defmodule Neo4ex.PackStream.DecoderTest do
  use ExUnit.Case, async: true

  alias Neo4ex.PackStream.Decoder

  describe "decode/1" do
    test "decodes basic types" do
      assert {nil, ""} == Decoder.decode(<<0xC0>>)
      assert {false, ""} == Decoder.decode(<<0xC2>>)
      assert {true, ""} == Decoder.decode(<<0xC3>>)
      assert {[], ""} == Decoder.decode(<<0x90>>)
      assert {123, ""} == Decoder.decode(<<0x7B>>)
      assert {32_767, ""} == Decoder.decode(<<0xC9, 32_767::16>>)
      assert {<<1, 2, 3, 4>>, ""} == Decoder.decode(<<0xCC, 4, 1, 2, 3, 4>>)
      assert {2.0, ""} == Decoder.decode(<<0xC1, 0x40, 0x0::56>>)

      # make sure longer data is properly matched
      assert {"Qui quasi facilis magnam quo! Sed qui quod sit excepturi quasi. Aut architecto occaecati nihil! Perspiciatis velit nulla eum cumque consequatur rerum sit quo. Quia illum ipsum repellendus.",
              ""} ==
               Decoder.decode(
                 <<0xD1, 0x0, 0xBC, 0x51, 0x75, 0x69, 0x20, 0x71, 0x75, 0x61, 0x73, 0x69, 0x20,
                   0x66, 0x61, 0x63, 0x69, 0x6C, 0x69, 0x73, 0x20, 0x6D, 0x61, 0x67, 0x6E, 0x61,
                   0x6D, 0x20, 0x71, 0x75, 0x6F, 0x21, 0x20, 0x53, 0x65, 0x64, 0x20, 0x71, 0x75,
                   0x69, 0x20, 0x71, 0x75, 0x6F, 0x64, 0x20, 0x73, 0x69, 0x74, 0x20, 0x65, 0x78,
                   0x63, 0x65, 0x70, 0x74, 0x75, 0x72, 0x69, 0x20, 0x71, 0x75, 0x61, 0x73, 0x69,
                   0x2E, 0x20, 0x41, 0x75, 0x74, 0x20, 0x61, 0x72, 0x63, 0x68, 0x69, 0x74, 0x65,
                   0x63, 0x74, 0x6F, 0x20, 0x6F, 0x63, 0x63, 0x61, 0x65, 0x63, 0x61, 0x74, 0x69,
                   0x20, 0x6E, 0x69, 0x68, 0x69, 0x6C, 0x21, 0x20, 0x50, 0x65, 0x72, 0x73, 0x70,
                   0x69, 0x63, 0x69, 0x61, 0x74, 0x69, 0x73, 0x20, 0x76, 0x65, 0x6C, 0x69, 0x74,
                   0x20, 0x6E, 0x75, 0x6C, 0x6C, 0x61, 0x20, 0x65, 0x75, 0x6D, 0x20, 0x63, 0x75,
                   0x6D, 0x71, 0x75, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x65, 0x71, 0x75, 0x61,
                   0x74, 0x75, 0x72, 0x20, 0x72, 0x65, 0x72, 0x75, 0x6D, 0x20, 0x73, 0x69, 0x74,
                   0x20, 0x71, 0x75, 0x6F, 0x2E, 0x20, 0x51, 0x75, 0x69, 0x61, 0x20, 0x69, 0x6C,
                   0x6C, 0x75, 0x6D, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6D, 0x20, 0x72, 0x65, 0x70,
                   0x65, 0x6C, 0x6C, 0x65, 0x6E, 0x64, 0x75, 0x73, 0x2E>>
               )

      # Lists and maps work a bit different
      assert {["abba", "baba"], ""} ==
               <<0x92, 0x84, "abba", 0x84, "baba">>
               |> Decoder.decode()
               |> then(fn {list, bin} ->
                 Enum.map_reduce(list, bin, fn _, d -> Decoder.decode(d) end)
               end)

      assert {%{"a" => "abba", "b" => "baba"}, ""} ==
               <<0xA2, 0x81, "a", 0x84, "abba", 0x81, "b", 0x84, "baba">>
               |> Decoder.decode()
               |> then(fn {%{size: map_size}, bin} ->
                 {data, rest} =
                   Enum.map_reduce(1..map_size, bin, fn _, d ->
                     {key, d} = Decoder.decode(d)
                     {value, d} = Decoder.decode(d)
                     {{key, value}, d}
                   end)

                 {Enum.into(data, %{}), rest}
               end)
    end
  end
end
